#!/usr/bin/env python3
"""
This script auto-generates the c++ file LookupTables.cpp.
"""

tiles = [
    'tCCCC110',
    'tCCCF100',
    'tCCCF110',
    'tCCCR100',
    'tCCCR110',
    'tCCFF100',
    'tCCFF110',
    'tCCFF200',
    'tCCRR100',
    'tCCRR110',
    'tCFCF100',
    'tCFCF110',
    'tCFCF200',
    'tCFFF100',
    'tCFRR100',
    'tCRFR100',
    'tCRRF100',
    'tCRRR100',
    'tFFFF001',
    'tFFFR001',
    'tFFRR000',
    'tFRFR000',
    'tFRRR000',
    'tRRRR000'
]

assert len(tiles) == 24

directions = [
    'dN',
    'dE',
    'dS',
    'dW'
    ]


placements = [
    'mN',
    'mE',
    'mS',
    'mW',
    'mNE',
    'mSE',
    'mSW',
    'mNW'
    ]

mN = 1 << 0
mE = 1 << 1
mS = 1 << 2
mW = 1 << 3
mNE = 1 << 4
mSE = 1 << 5
mSW = 1 << 6
mNW = 1 << 7


# On a given tile, some terrain regions can have multiple possible representations. This leads to
# multiple possible placement values for a given tile. We always choose the smallest possible
# value, for elegance. The below table captures these values. It was computed by hand.
placements_dict = {
    'tCCCC110': mN,
    'tCCCF100': mN | mSW,
    'tCCCF110': mN | mSW,
    'tCCCR100': mN | mW | mSW | mNW,
    'tCCCR110': mN | mW | mSW | mNW,
    'tCCFF100': mN | mSE,
    'tCCFF110': mN | mSE,
    'tCCFF200': mN | mE | mNE,
    'tCCRR100': mN | mS | mSE | mSW,
    'tCCRR110': mN | mS | mSE | mSW,
    'tCFCF100': mN | mNE | mSW,
    'tCFCF110': mN | mNE | mSW,
    'tCFCF200': mN | mS | mNE,
    'tCFFF100': mN | mNE,
    'tCFRR100': mN | mS | mNE | mSW,
    'tCRFR100': mN | mE | mNE | mSE,
    'tCRRF100': mN | mE | mNE | mSE,
    'tCRRR100': mN | mE | mS | mW | mNE | mSE | mSW,
    'tFFFF001': mNE,
    'tFFFR001': mNE | mW,
    'tFFRR000': mS | mNE | mSW,
    'tFRFR000': mE | mNE | mSE,
    'tFRRR000': mE | mS | mW | mNE | mSE | mSW,
    'tRRRR000': mN | mE | mS | mW | mNE | mSE | mSW | mNW,
}

def rotate_tile(tile, num_rotations):
    return tile[-num_rotations:] + tile[:-num_rotations]


def rotate_4bits(value, num_rotations):
    return ((value << num_rotations) | (value >> (4 - num_rotations))) & 0xF


valid_orientations_table = [0] * 4


valid_orientation_set = set()

for t, full_tile in enumerate(tiles):
    tile = full_tile[1:5]
    tile_set = set()

    for d in range(4):
        tile2 = rotate_tile(tile, d)
        if tile2 in tile_set:
            continue
        tile_set.add(tile2)
        valid_orientation_set.add((t, d))
        valid_orientations_table[d] |= 1 << t


def write_valid_orientations_table():
    print('const uint32_t kValidOrientationTable[4] = {')
    for o in range(4):
        suffix = ',' if o < 3 else ' '
        comment = f'// {directions[o]}'
        print(f'  0x{valid_orientations_table[o]:08x}{suffix}  {comment}')
    print('};\n')


def edge_value(t):
    if t == 'F':
        return 1
    if t == 'R':
        return 2
    if t == 'C':
        return 3
    assert False, t


edge_profiles_table = []
meeple_location_profiles_table = []


for t, full_tile in enumerate(tiles):
    tile = full_tile[1:5]

    for d, direction in enumerate(directions):
        tile2 = rotate_tile(tile, d)
        edge_profile_value = 0
        for k in range(4):
            edge_profile_value *= 4
            edge_profile_value += edge_value(tile2[k])

        comment = f'{full_tile} {direction} -> {tile2}'
        valid = (t, d) in valid_orientation_set
        if not valid:
            comment += ' (invalid)'
        edge_profiles_table.append((edge_profile_value, comment))

    p_value = placements_dict[full_tile]
    p_high = p_value >> 4
    p_low = p_value & 0xF

    for d, direction in enumerate(directions):
        tile2 = rotate_tile(tile, d)
        p_high2 = rotate_4bits(p_high, d)
        p_low2 = rotate_4bits(p_low, d)
        p_value2 = (p_high2 << 4) | p_low2
        comment = f'{full_tile} {direction} -> {tile2}'
        valid = (t, d) in valid_orientation_set
        if not valid:
            comment += ' (invalid)'
        meeple_location_profiles_table.append((p_value2, comment))


def write_edge_profiles_table():
    n = len(edge_profiles_table)
    print('const uint8_t kEdgeProfileTable[4 * kNumTileTypes] = {')
    for i, (value, comment) in enumerate(edge_profiles_table):
        comma = ',' if i < n - 1 else ' '
        print(f'  0x{value:02x}{comma}  // {comment}')
    print('};\n')


def write_meeple_location_profiles_table():
    n = len(meeple_location_profiles_table)
    print('const uint8_t kMeepleLocationProfileTable[4 * kNumTileTypes] = {')
    for i, (value, comment) in enumerate(meeple_location_profiles_table):
        comma = ',' if i < n - 1 else ' '
        print(f'  0x{value:02x}{comma}  // {comment}')
    print('};\n')


def write_header():
    print('// Auto-generated by py/carassonne/lookup_tables_writer.py')
    print('#include <games/carcassonne/LookupTables.hpp>')
    print('')
    print('namespace carcassonne {\n')


def write_footer():
    print('}  // namespace carcassonne\n')


write_header()
write_valid_orientations_table()
write_edge_profiles_table()
write_meeple_location_profiles_table()
write_footer()
